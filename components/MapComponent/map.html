<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    html,
    body,
    #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .pulse-marker {
      position: relative;
      width: 24px;
      height: 24px;
    }

    .pulse-outer {
      position: absolute;
      top: 0;
      left: 0;
      width: 24px;
      height: 24px;
      background: #2196f3;
      opacity: 0.3;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }

    .pulse-inner {
      position: absolute;
      top: 4px;
      left: 4px;
      width: 12px;
      height: 12px;
      background: #2196f3;
      border-radius: 50%;
      border: 2px solid #fff;
      box-shadow: 0 0 4px #2196f3;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 0.3;
      }

      50% {
        transform: scale(1.7);
        opacity: 0.1;
      }

      100% {
        transform: scale(1);
        opacity: 0.3;
      }
    }

    /* Controls */
    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      padding: 8px 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 1000;
      min-width: 200px;
    }

    .controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      margin: 4px 0;
    }

    .controls .row {
      display: flex;
      gap: 6px;
      align-items: center;
      margin-top: 6px;
    }

    .controls input[type="text"] {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #ccc;
      font-size: 13px;
    }

    .controls button {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #1f6feb;
      background: #1f6feb;
      color: #fff;
      font-size: 13px;
    }

    .controls button:active {
      transform: translateY(1px);
    }

    /* Loading indicator */
    #loading {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      display: none;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 6px 10px 16px 10px;
      border-radius: 8px;
      font-size: 12px;
      min-width: 120px;
    }

    #loading-bar {
      position: absolute;
      left: 0;
      bottom: 0;
      height: 4px;
      width: 100%;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 0 0 8px 8px;
      overflow: hidden;
    }

    #loading-bar-inner {
      height: 100%;
      width: 0%;
      background: #1f6feb;
      border-radius: 0 0 8px 8px;
      transition: width 0.3s cubic-bezier(.4, 0, .2, 1);
    }

    /* Toast */
    #toast {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 1100;
      display: none;
      max-width: 90%;
      text-align: center;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="loading">Carregando…
    <div id="loading-bar">
      <div id="loading-bar-inner"></div>
    </div>
  </div>
  <div id="toast"></div>
  <div class="controls">
    <label><input id="chkBuses" type="checkbox" checked /> Mostrar ônibus</label>
    <label><input id="chkStops" type="checkbox" checked /> Mostrar paradas</label>
    <label><input id="chkOnlyActive" type="checkbox" /> Apenas ônibus ativos</label>
    <div class="row" style="flex-direction:column;align-items:stretch;">
      <div id="selectedLines" style="display:flex;flex-wrap:wrap;gap:4px;margin-bottom:4px;"></div>
      <input id="txtLine" type="text" placeholder="Buscar linha (ex: 0.123)" autocomplete="off" />
      <div id="autocompleteList" style="position:relative;"></div>
    </div>
    <button id="btnSearch" style="margin-top:6px;">Buscar</button>
  </div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script>

    const INITIAL_LAT = 15.7801; // Latitude for initial map center
    const INITIAL_LNG = -47.9292; // Longitude for initial map center
    const INITIAL_ZOOM = 15; // Initial map zoom level

    // UI helpers
    var loadingBarTimer = null;
    function setLoading(active, text) {
      try {
        var el = document.getElementById('loading');
        var bar = document.getElementById('loading-bar-inner');
        if (!el) return;
        if (typeof text === 'string' && text) {
          // Só altera o texto, não remove a barra
          el.childNodes[0].textContent = text;
        }
        if (active) {
          el.style.display = 'block';
          if (bar) {
            bar.style.width = '0%';
            setTimeout(function () { bar.style.width = '80%'; }, 50);
            clearTimeout(loadingBarTimer);
            loadingBarTimer = setTimeout(function () { bar.style.width = '95%'; }, 2000);
          }
        } else {
          if (bar) {
            bar.style.width = '100%';
            setTimeout(function () { el.style.display = 'none'; bar.style.width = '0%'; }, 400);
          } else {
            el.style.display = 'none';
          }
          clearTimeout(loadingBarTimer);
        }
      } catch (e) { }
    }
    var toastTimer = null;
    function showToast(msg, ms) {
      try {
        var el = document.getElementById('toast');
        if (!el) return;
        el.textContent = String(msg || '');
        el.style.display = 'block';
        clearTimeout(toastTimer);
        toastTimer = setTimeout(function () { el.style.display = 'none'; }, Math.max(1500, ms || 2500));
      } catch (e) { }
    }

    function rnLog(tag, msg, extra) {
      try {
        var payload = { type: 'log', tag: String(tag || ''), msg: String(msg || ''), extra: extra };
        window.ReactNativeWebView && window.ReactNativeWebView.postMessage(JSON.stringify(payload));
      } catch (e) { /* noop */ }
    }
    // RN fetch bridge state
    window.__pending = {};
    window.__reqId = 1;
    function nativeFetch(url) {
      try {
        var id = window.__reqId++;
        return new Promise(function (resolve, reject) {
          var to = setTimeout(function () { try { delete window.__pending[id]; } catch (e) { }; reject(new Error('timeout')); }, 15000);
          window.__pending[id] = { resolve: resolve, reject: reject, t: to };
          var payload = { type: 'fetch', id: id, url: String(url) };
          window.ReactNativeWebView && window.ReactNativeWebView.postMessage(JSON.stringify(payload));
        });
      } catch (e) { return Promise.reject(e); }
    }
    window.__deliverFetchText = function (id, ok, status, text) {
      try {
        var entry = window.__pending && window.__pending[id];
        if (!entry) return;
        clearTimeout(entry.t);
        delete window.__pending[id];
        if (ok) {
          try {
            var json = JSON.parse(text);
            entry.resolve(json);
          } catch (e) {
            entry.reject(new Error('invalid json'));
          }
        } else {
          entry.reject(new Error('HTTP ' + status));
        }
      } catch (e) { /* noop */ }
    }
    // Keep map persistent regardless of RN prop changes
    var map = L.map('map').setView([INITIAL_LAT, INITIAL_LNG], INITIAL_ZOOM);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
    }).addTo(map);
    rnLog('INIT', 'Leaflet map created');

    // UI state
    var showStops = true, showBuses = true;
    var clusterEnabled = true; // clustering is default and always on
    var showOnlyActiveBuses = false; // when true, only buses with a linha value are shown
    // Multiselect de linhas
    var allLinesList = []; // [{label, value}]
    var selectedLines = []; // [{label, value}]
    var filterLine = '';
    function normalizeLine(s) {
      var t = (s == null ? '' : String(s)).toUpperCase().trim();
      return { raw: t, digits: t.replace(/[^0-9]/g, '').replace(/^0+/, '') };
    }
    function renderSelectedLines() {
      var cont = document.getElementById('selectedLines');
      if (!cont) return;
      cont.innerHTML = '';
      selectedLines.forEach(function (line, idx) {
        var chip = document.createElement('span');
        chip.style.cssText = 'background:#e3e3e3;border-radius:12px;padding:2px 8px 2px 8px;display:flex;align-items:center;font-size:13px;margin:2px;';
        chip.textContent = line.label + ' ';
        var x = document.createElement('span');
        x.textContent = '×';
        x.style.cssText = 'margin-left:4px;cursor:pointer;color:#c30505;font-weight:bold;';
        x.onclick = function () {
          selectedLines.splice(idx, 1);
          renderSelectedLines();
          refreshBuses();
        };
        chip.appendChild(x);
        cont.appendChild(chip);
      });
    }
    function updateAutocompleteList(val) {
      var list = document.getElementById('autocompleteList');
      if (!list) return;
      list.innerHTML = '';
      var norm = (val || '').toUpperCase().trim();
      // if dont have any value, show all buses lines
      var filtered = !norm
        ? allLinesList.slice(0, 100) // up to 100 to not lag
        : allLinesList.filter(function (l) {
            return l.label.indexOf(norm) !== -1 || l.value.indexOf(norm) !== -1;
          }).slice(0, 100);
      filtered.forEach(function (line) {
        var item = document.createElement('div');
        item.textContent = line.label;
        item.style.cssText = 'background:#fff;border:1px solid #ccc;padding:4px 8px;cursor:pointer;';
        item.onclick = function () {
          if (!selectedLines.some(function (l) { return l.value === line.value; })) {
            selectedLines.push(line);
            renderSelectedLines();
            refreshBuses();
          }
          document.getElementById('txtLine').value = '';
          list.innerHTML = '';
        };
        list.appendChild(item);
      });
      list.style.maxHeight = '200px';
      list.style.overflowY = 'auto';
      list.style.position = 'absolute';
      list.style.width = '91%';
      list.style.zIndex = 1001;
      list.style.bottom = 'auto';
      list.style.marginTop = '40px';
    }

    // Custom pulsating marker
    var userIcon = L.divIcon({
      className: '',
      html: '<div class="pulse-marker"><div class="pulse-outer"></div><div class="pulse-inner"></div></div>',
      iconSize: [24, 24],
      iconAnchor: [12, 12],
    });

    // Create a user marker reference (hidden by default)
    var userMarker = L.marker([INITIAL_LAT, INITIAL_LNG], { icon: userIcon });
    var userMarkerVisible = false; // default hidden to avoid flashing at initial position

    // Expose a function to recenter and move the marker from RN
    window.setUserPosition = function (lat, lng, z) {
      try {
        userMarker.setLatLng([lat, lng]);
        // Keep current zoom if not provided
        var targetZoom = (typeof z === 'number' && !isNaN(z)) ? z : map.getZoom();
        map.flyTo([lat, lng], targetZoom, { animate: true, duration: 0.6 });
        // Ensure marker is shown only when visibility is enabled
        if (userMarkerVisible && !map.hasLayer(userMarker)) {
          userMarker.addTo(map);
        }
      } catch (e) { /* noop */ }
    }

    // Recenter without touching marker state
    window.recenterOnly = function (lat, lng, z) {
      try {
        var targetZoom = (typeof z === 'number' && !isNaN(z)) ? z : map.getZoom();
        map.flyTo([lat, lng], targetZoom, { animate: true, duration: 0.6 });
      } catch (e) { /* noop */ }
    }

    // Show/hide the user marker
    window.setUserMarkerVisible = function (visible) {
      try {
        userMarkerVisible = !!visible;
        if (userMarkerVisible) {
          if (!map.hasLayer(userMarker)) { userMarker.addTo(map); }
        } else {
          if (map.hasLayer(userMarker)) { map.removeLayer(userMarker); }
        }
      } catch (e) { /* noop */ }
    }

    // =========================
    // WFS endpoints & helpers
    // =========================
    var WFS_URLS = {
      buses: 'http://geoserver.semob.df.gov.br/geoserver/semob/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=semob%3A%C3%9Altima%20posi%C3%A7%C3%A3o%20da%20frota&outputFormat=application%2Fjson',
      stops: 'http://geoserver.semob.df.gov.br/geoserver/semob/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=semob%3AParadas%20de%20onibus&outputFormat=application%2Fjson',
      lines: 'http://geoserver.semob.df.gov.br/geoserver/semob/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=semob%3ALinhas%20de%20onibus&outputFormat=application%2Fjson'
    };

    function bboxParamFromMap() {
      try {
        var b = map.getBounds();
        // WFS bbox expects lon,lat order in EPSG:4326
        var sw = b.getSouthWest();
        var ne = b.getNorthEast();
        return sw.lng + ',' + sw.lat + ',' + ne.lng + ',' + ne.lat;
      } catch (e) { return null; }
    }

    function withBbox(url) {
      try {
        var u = new URL(url);
        var bbox = bboxParamFromMap();
        if (bbox) {
          u.searchParams.set('bbox', bbox + ',EPSG:4326');
        }
        if (!u.searchParams.has('srsName')) {
          u.searchParams.set('srsName', 'EPSG:4326');
        }
        return u.toString();
      } catch (e) { return url; }
    }

    function bboxParamFromBounds(b) {
      try {
        var sw = b.getSouthWest();
        var ne = b.getNorthEast();
        return sw.lng + ',' + sw.lat + ',' + ne.lng + ',' + ne.lat;
      } catch (e) { return null; }
    }

    function withBboxForBounds(url, bounds) {
      try {
        var u = new URL(url);
        var bbox = bboxParamFromBounds(bounds);
        if (bbox) {
          u.searchParams.set('bbox', bbox + ',EPSG:4326');
        }
        if (!u.searchParams.has('srsName')) {
          u.searchParams.set('srsName', 'EPSG:4326');
        }
        return u.toString();
      } catch (e) { return url; }
    }

    function fetchJson(url) {
      // rnLog('NET', 'GET ' + url);
      if (window.ReactNativeWebView) {
        // Use RN bridge to bypass CORS in WebView
        return nativeFetch(url).catch(function (e) { rnLog('NET', 'FETCH_ERR ' + url, String(e && e.message || e)); throw e; });
      } else {
        return fetch(url, { headers: { 'accept': 'application/json' }, cache: 'no-store' })
          .then(function (r) { if (!r.ok) { rnLog('NET', 'HTTP ' + r.status + ' ' + url); throw new Error('HTTP ' + r.status); } return r.json(); })
          .catch(function (e) { rnLog('NET', 'FETCH_ERR ' + url, String(e && e.message || e)); throw e; });
      }
    }

    // =========================
    // Lines dataset preload/cache
    // =========================
    var linesCache = null; // FeatureCollection
    var linesRequested = false;
    function ensureLinesDataset() {
      if (linesCache) { rnLog('LINES', 'cache-hit', { total: (linesCache.features || []).length }); return Promise.resolve(linesCache); }
      if (linesRequested) {
        rnLog('LINES', 'already-requested');
        return new Promise(function (res, rej) {
          var waited = 0; var it = setInterval(function () {
            if (linesCache) { clearInterval(it); res(linesCache); }
            waited += 250; if (waited > 15000) { clearInterval(it); rej(new Error('timeout lines')); }
          }, 250);
        });
      }
      linesRequested = true;
      rnLog('LINES', 'preload-start');
      return fetchJson(WFS_URLS.lines)
        .then(function (geojson) { linesCache = geojson; rnLog('LINES', 'preload-done', { total: (geojson.features || []).length }); return geojson; })
        .catch(function (e) { rnLog('LINES', 'preload-error', String(e && e.message || e)); throw e; })
        .finally(function () { linesRequested = false; });
    }

    // =========================
    // Icons
    // =========================
    function makeStopIcon(size) {
      return L.icon({
        iconUrl: 'data:image/svg+xml;utf8,' + encodeURIComponent(`
          <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 28 28">
            <defs>
              <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                <feDropShadow dx="0" dy="1" stdDeviation="1" flood-color="#000" flood-opacity="0.3"/>
              </filter>
            </defs>
            <rect x="5" y="3" width="18" height="14" rx="3" ry="3" fill="#32cd32" filter="url(#shadow)"/>
            <path d="M9 17 L19 17 L14 23 Z" fill="#32cd32" filter="url(#shadow)"/>
            <rect x="7.5" y="7" width="1" height="5" fill="#fff"/>
            <rect x="6.5" y="5" width="3" height="2" rx="0.5" ry="0.5" fill="#2e7d32"/>
            <rect x="10" y="6" width="9" height="1.2" fill="#fff"/>
            <rect x="10" y="7" width="0.8" height="5" fill="#fff"/>
            <rect x="18.2" y="7" width="0.8" height="5" fill="#fff"/>
            <rect x="11" y="10" width="7" height="1.2" rx="0.3" fill="#fff"/>
          </svg>
        `),
        iconSize: [size, size],
        iconAnchor: [size / 2, size * 0.9],
        popupAnchor: [0, -size * 0.7]
      });
    }

    function makeBusIcon(size) {
      return L.icon({
        iconUrl: 'data:image/svg+xml;utf8,' + encodeURIComponent(`
          <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 28 28">
            <defs>
              <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                <feDropShadow dx="0" dy="1" stdDeviation="1" flood-color="#000" flood-opacity="0.3"/>
              </filter>
            </defs>
            <rect x="3" y="3" width="22" height="22" rx="4" ry="4" fill="#c30505ff" filter="url(#shadow)"/>
            <rect x="7.5" y="9" width="1" height="2" rx="0.3" fill="#000"/>
            <rect x="19.5" y="9" width="1" height="2" rx="0.3" fill="#000"/>
            <rect x="9" y="7" width="10" height="10" rx="2" ry="2" fill="#fff"/>
            <rect x="10.5" y="8.5" width="7" height="4" rx="1" ry="1" fill="#bcbcbcff"/>
            <rect x="10.5" y="13.5" width="7" height="2" fill="#949494ff"/>
            <circle cx="11.5" cy="16.5" r="0.9" fill="#fff"/>
            <circle cx="16.5" cy="16.5" r="0.9" fill="#fff"/>
            <rect x="9.5" y="17.8" width="2" height="2" rx="0.5" fill="#000"/>
            <rect x="16.5" y="17.8" width="2" height="2" rx="0.5" fill="#000"/>
          </svg>
        `),
        iconSize: [size, size],
        iconAnchor: [size / 2, size * 0.9],
        popupAnchor: [0, -size * 0.7]
      });
    }
    function iconSizeForZoom(z) {
      var minZ = 10, maxZ = 16, minS = 28, maxS = 48;
      var clamped = Math.max(minZ, Math.min(maxZ, z));
      var t = (clamped - minZ) / (maxZ - minZ);
      return Math.round(minS + t * (maxS - minS));
    }

    var currentStopIcon = makeStopIcon(iconSizeForZoom(map.getZoom()));
    var currentBusIcon = makeBusIcon(iconSizeForZoom(map.getZoom()));

    map.on('zoomend', function () {
      var size = Math.min(iconSizeForZoom(map.getZoom()), 42);
      currentStopIcon = makeStopIcon(size);
      currentBusIcon = makeBusIcon(size);
      try { stopsLayer.eachLayer(function (m) { m.setIcon && m.setIcon(currentStopIcon); }); } catch (e) { }
      try { busesLayer.eachLayer(function (m) { m.setIcon && m.setIcon(currentBusIcon); }); } catch (e) { }
      try { if (stopsCluster) { stopsCluster.eachLayer(function (m) { m.setIcon && m.setIcon(currentStopIcon); }); if (stopsCluster.refreshClusters) { stopsCluster.refreshClusters(); } } } catch (e) { }
      try { if (busesCluster) { busesCluster.eachLayer(function (m) { m.setIcon && m.setIcon(currentBusIcon); }); if (busesCluster.refreshClusters) { busesCluster.refreshClusters(); } } } catch (e) { }
      rnLog('MAP', 'zoomend', { zoom: map.getZoom(), iconSize: size });
    });

    // =========================
    // Layers
    // =========================
    var routeLayer = L.geoJSON(null, { style: { color: '#1f6feb', weight: 4, opacity: 0.9 } }).addTo(map);
    var stopsLayer = L.geoJSON(null, {
      pointToLayer: function (feature, latlng) { return L.marker(latlng, { icon: currentStopIcon }); },
      onEachFeature: function (feature, layer) {
        var props = feature && feature.properties || {};
        var title = (props.descricao || props.ds_ponto || props.nm_parada || props.nome || props.ds_descricao || 'Parada de ônibus');
        var codigo = (props.cd_parada || props.codigo || props.id || props.id_parada || '—');
        layer.bindPopup('<strong>' + String(title) + '</strong><br/>Parada ' + String(codigo));
      }
    }).addTo(map);
    var busesLayer = L.geoJSON(null, {
      pointToLayer: function (feature, latlng) { return L.marker(latlng, { icon: currentBusIcon }); },
      onEachFeature: function (feature, layer) {
        var p = feature && feature.properties || {};
        var prefixo = p.prefixo || '—';
        var linha = (p.cd_linha || p.linha || p.servico || '—');
        var velocidade = (p.velocidade != null ? p.velocidade : '—');
        var sentido = (p.sentido != null ? p.sentido : '—');
        var datalocal = (p.datalocal != null ? p.datalocal : '—');
        var tarifa = (p.tarifa || p.vl_tarifa || p.valor_tarifa || p.preco || p.valor);
        function fmtTarifa(v) { var n = Number(v); return isFinite(n) ? ('R$ ' + n.toFixed(2).replace('.', ',')) : null; }
        var tarifaLine = (tarifa != null && tarifa !== '' && tarifa !== '—') ? ('<br/>Tarifa: ' + (fmtTarifa(tarifa) || String(tarifa))) : '';
        var html = '<div><strong>Ônibus ' + String(prefixo) + '</strong><br/>' +
          'Linha: ' + String(linha) + '<br/>' +
          'Velocidade: ' + String(velocidade) + ' km/h<br/>' +
          'Sentido: ' + String(sentido) + '<br/>' +
          'Data local: ' + String(datalocal) +
          tarifaLine +
          '</div>';
        layer.bindPopup(html);
        layer.on('popupopen', function () {
          var codeRaw = (p.cd_linha || p.linha || p.servico || '').toString().trim();
          if (codeRaw) { window.setBusRoute(codeRaw); }
        });
      }
    }).addTo(map);
    var stopsCluster = null, busesCluster = null;
    function ensureClusters() {
      if (!clusterEnabled) return;
      if (!L.markerClusterGroup) { showToast('Plugin de cluster não disponível'); clusterEnabled = false; return; }
      var created = false;
      if (!stopsCluster) {
        stopsCluster = L.markerClusterGroup({
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
          zoomToBoundsOnClick: true,
          disableClusteringAtZoom: 18,
          removeOutsideVisibleBounds: true,
          spiderfyDistanceMultiplier: 1.2,
          maxClusterRadius: function (zoom) {
            if (zoom >= 18) return 1; // effectively no clustering at very high zoom
            if (zoom >= 17) return 20;
            if (zoom >= 16) return 40;
            return 80;
          }
        });
        created = true;
      }
      if (!busesCluster) {
        busesCluster = L.markerClusterGroup({
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
          zoomToBoundsOnClick: true,
          disableClusteringAtZoom: 18,
          removeOutsideVisibleBounds: true,
          spiderfyDistanceMultiplier: 1.2,
          maxClusterRadius: function (zoom) {
            if (zoom >= 18) return 1;
            if (zoom >= 17) return 20;
            if (zoom >= 16) return 10;
            return 60;
          }
        });
        created = true;
      }
      // Attach to map if visible
      if (showStops && !map.hasLayer(stopsCluster)) { stopsCluster.addTo(map); }
      if (showBuses && !map.hasLayer(busesCluster)) { busesCluster.addTo(map); }
      // When clustering is active, hide base layers to avoid duplicates
      try { if (map.hasLayer(stopsLayer)) { map.removeLayer(stopsLayer); } } catch (e) { }
      try { if (map.hasLayer(busesLayer)) { map.removeLayer(busesLayer); } } catch (e) { }
      // If clusters were created now, seed them from existing layers
      if (created) { try { rebuildStopsCluster(); rebuildBusesCluster(); } catch (e) { } }
    }
    function clearClusters() {
      try { if (stopsCluster) { stopsCluster.clearLayers(); } } catch (e) { }
      try { if (busesCluster) { busesCluster.clearLayers(); } } catch (e) { }
    }
    function rebuildStopsCluster() {
      if (!clusterEnabled || !stopsCluster) return;
      try { stopsCluster.clearLayers(); } catch (e) { }
      try {
        stopsLayer.eachLayer(function (m) {
          try {
            var ll = m.getLatLng && m.getLatLng();
            if (!ll) return;
            var mk = L.marker(ll, { icon: currentStopIcon });
            if (m.getPopup && m.getPopup()) { mk.bindPopup(m.getPopup()); }
            stopsCluster.addLayer(mk);
          } catch (e) { }
        });
        if (stopsCluster.refreshClusters) { stopsCluster.refreshClusters(); }
      } catch (e) { }
    }
    function rebuildBusesCluster() {
      if (!clusterEnabled || !busesCluster) return;
      try { busesCluster.clearLayers(); } catch (e) { }
      try {
        busesLayer.eachLayer(function (m) {
          try {
            var ll = m.getLatLng && m.getLatLng();
            if (!ll) return;
            var mk = L.marker(ll, { icon: currentBusIcon });
            if (m.getPopup && m.getPopup()) { mk.bindPopup(m.getPopup()); }
            mk.on('popupopen', function () {
              var p = m.feature && m.feature.properties || {};
              var codeRaw = (p.cd_linha || p.linha || p.servico || '').toString().trim();
              if (codeRaw) { window.setBusRoute(codeRaw); }
            });
            busesCluster.addLayer(mk);
          } catch (e) { }
        });
        if (busesCluster.refreshClusters) { busesCluster.refreshClusters(); }
      } catch (e) { }
    }

    // =========================
    // Data loading
    // =========================
    var stopsCache = { geojson: null, bounds: null }; // cache with bounds snapshot
    var stopsRequested = false;
    function boundsChangedSignificantly(oldB, newB) {
      try {
        if (!oldB || !newB) return true;
        var oldC = oldB.getCenter && oldB.getCenter();
        var newC = newB.getCenter && newB.getCenter();
        if (!oldC || !newC) return true;
        var dist = map.distance(oldC, newC);
        // compare vertical span as a proxy for zoom/extent change
        var oldSpan = Math.abs(oldB.getNorthEast().lat - oldB.getSouthWest().lat);
        var newSpan = Math.abs(newB.getNorthEast().lat - newB.getSouthWest().lat);
        return dist > 1000 || Math.abs(oldSpan - newSpan) > 0.01;
      } catch (e) { return true; }
    }
    function loadStopsForBounds(bounds) {
      setLoading(true, 'Carregando paradas…');
      // pad bounds a bit to cover slight pans
      var b = null;
      try { b = bounds && bounds.pad ? bounds.pad(0.2) : bounds; } catch (e) { b = bounds; }
      // If we have cache for similar bounds, just render cached data
      try {
        if (stopsCache.geojson && stopsCache.bounds && !boundsChangedSignificantly(stopsCache.bounds, b)) {
          rnLog('STOPS', 'cache-hit', { count: (stopsCache.geojson.features || []).length });
          stopsLayer.clearLayers();
          stopsLayer.addData(stopsCache.geojson);
          if (clusterEnabled) { ensureClusters(); rebuildStopsCluster(); if (map.hasLayer(stopsLayer)) { map.removeLayer(stopsLayer); } }
          setLoading(false);
          return Promise.resolve();
        }
      } catch (e) { /* fallback to network */ }
      if (stopsRequested) { rnLog('STOPS', 'already-requested'); setLoading(false); return Promise.resolve(); }
      stopsRequested = true;
      var url = b ? withBboxForBounds(WFS_URLS.stops, b) : withBbox(WFS_URLS.stops);
      // rnLog('STOPS', 'load', { url: url });
      return fetchJson(url)
        .then(function (geojson) {
          stopsCache = { geojson: geojson, bounds: b };
          try {
            stopsLayer.clearLayers();
            stopsLayer.addData(geojson);
            var count = (geojson && geojson.features && geojson.features.length) || 0;
            rnLog('STOPS', 'loaded', { count: count });
            if (clusterEnabled) { ensureClusters(); rebuildStopsCluster(); if (map.hasLayer(stopsLayer)) { map.removeLayer(stopsLayer); } }
          } catch (e) { rnLog('STOPS', 'layer_error', String(e && e.message || e)); }
        })
        .catch(function (e) { rnLog('STOPS', 'error', String(e && e.message || e)); showToast('Erro ao carregar paradas'); })
        .finally(function () { stopsRequested = false; setLoading(false); });
    }
    var lastBusesGeoJson = null;
    function isActiveBusFeature(feat) {
      try {
        var p = (feat && feat.properties) || {};
        var v = (p.cd_linha || p.linha || p.servico || '').toString().trim().toUpperCase();
        if (!v) return false;
        if (v === 'NULL' || v === 'N/A') return false;
        return true;
      } catch (e) { return false; }
    }
    function refreshBuses() {
      var url = withBbox(WFS_URLS.buses);
      setLoading(true, 'Carregando ônibus…');
      return fetchJson(url)
        .then(function (geojson) {
          lastBusesGeoJson = geojson;
          try {
            // updates the autocomplete
            var feats = (geojson && geojson.features) || [];
            // Log detalhado dos ônibus encontrados
            try {
              var logArr = feats.map(function (f) {
                var p = f.properties || {};
                var coords = (f.geometry && f.geometry.coordinates) ? f.geometry.coordinates : [];
                return {
                  prefixo: p.prefixo,
                  linha: p.cd_linha || p.linha || p.servico,
                  datalocal: p.datalocal,
                  coords: coords
                };
              });
              // rnLog('BUSES', 'found', logArr);
            } catch (e) { }
            var seen = {};
            allLinesList = feats.map(function (f) {
              var p = f.properties || {};
              var label = (p.cd_linha || p.linha || p.servico || p.cd_linha_principal || p.codigo || p.cod_linha || '').toString().toUpperCase().trim();
              return { label: label, value: label };
            }).filter(function (l) {
              if (!l.label || seen[l.label]) return false;
              seen[l.label] = true;
              return true;
            });
            if (selectedLines.length > 0) {
              feats = feats.filter(function (feat) {
                var p = feat && feat.properties || {};
                var cands = [p.cd_linha, p.linha, p.servico, p.codigo, p.cod_linha]
                  .map(function (v) { return (v == null ? '' : String(v)).toUpperCase().trim(); });
                return selectedLines.some(function (line) {
                  return cands.includes(line.value);
                });
              });
            }
            if (showOnlyActiveBuses) {
              feats = feats.filter(isActiveBusFeature);
            }
            var filteredGeo = { type: 'FeatureCollection', features: feats };
            busesLayer.clearLayers();
              busesLayer.addData(filteredGeo);

              if (clusterEnabled) {
                rebuildBusesCluster();
                if (!map.hasLayer(busesCluster)) busesCluster.addTo(map);
                if (map.hasLayer(busesLayer)) map.removeLayer(busesLayer);
              } else {
                if (!map.hasLayer(busesLayer)) busesLayer.addTo(map);
                if (map.hasLayer(busesCluster)) map.removeLayer(busesCluster);
              }
          } catch (e) { rnLog('BUSES', 'layer_error', String(e && e.message || e)); }
        })
        .catch(function (e) { rnLog('BUSES', 'error', String(e && e.message || e)); showToast('Erro ao carregar ônibus'); })
        .finally(function () { setLoading(false); });
    }

    // Draw route by line code (use cached dataset; keep zoom/center)
    function setBusRoute(codeRaw) {
  if (!codeRaw) return;
  rnLog('ROUTE', 'setBusRoute start', { code: String(codeRaw) });
  ensureLinesDataset()
    .then(function (geojson) {
      var feats = (geojson && geojson.features) || [];
      var target = String(codeRaw).toUpperCase().trim();
      var digits = target.replace(/[^0-9]/g, '').replace(/^0+/, '');
      var filtered = feats.filter(function (f) {
        var pr = (f && f.properties) || {};
        var cands = [pr.cd_linha, pr.linha, pr.servico, pr.cd_linha_principal, pr.codigo, pr.cod_linha]
          .map(function (v) { var s = (v == null ? '' : String(v)).toUpperCase().trim(); return { raw: s, digits: s.replace(/[^0-9]/g, '').replace(/^0+/, '') }; })
          .filter(function (c) { return !!c.raw; });
        for (var i = 0; i < cands.length; i++) {
          if (cands[i].raw === target || (cands[i].digits && cands[i].digits === digits)) return true;
        }
        return false;
      });

      if (!filtered.length) {
        ensureLinesDataset(true).then(function (geojson2) {
          var feats2 = (geojson2 && geojson2.features) || [];
          var filtered2 = feats2.filter();
          routeLayer.clearLayers();
          routeLayer.addData({ type: 'FeatureCollection', features: filtered2 });
        });
        return;
      }

      routeLayer.clearLayers();
      routeLayer.addData({ type: 'FeatureCollection', features: filtered });
    })
    .catch(function (e) { rnLog('ROUTE', 'error', String(e && e.message || e)); });
}
    window.setBusRoute = setBusRoute;

    // UI bindings
    try {
      var chkBuses = document.getElementById('chkBuses');
      var chkStops = document.getElementById('chkStops');
      var chkOnlyActive = document.getElementById('chkOnlyActive');
      var txtLine = document.getElementById('txtLine');
      var btnSearch = document.getElementById('btnSearch');
      chkBuses.addEventListener('change', function () { showBuses = !!chkBuses.checked; if (clusterEnabled) { if (showBuses) { ensureClusters(); if (busesCluster && !map.hasLayer(busesCluster)) busesCluster.addTo(map); } else { if (busesCluster && map.hasLayer(busesCluster)) map.removeLayer(busesCluster); } } else { if (showBuses) { if (!map.hasLayer(busesLayer)) busesLayer.addTo(map); } else { if (map.hasLayer(busesLayer)) map.removeLayer(busesLayer); } } });
      chkStops.addEventListener('change', function () { showStops = !!chkStops.checked; if (clusterEnabled) { if (showStops) { ensureClusters(); if (stopsCluster && !map.hasLayer(stopsCluster)) stopsCluster.addTo(map); } else { if (stopsCluster && map.hasLayer(stopsCluster)) map.removeLayer(stopsCluster); } } else { if (showStops) { if (!map.hasLayer(stopsLayer)) stopsLayer.addTo(map); } else { if (map.hasLayer(stopsLayer)) map.removeLayer(stopsLayer); } } });
      if (chkOnlyActive) { chkOnlyActive.addEventListener('change', function () { showOnlyActiveBuses = !!chkOnlyActive.checked; refreshBuses(); }); }
      function applySearch() { refreshBuses(); if (selectedLines.length > 0) { try { window.setBusRoute(selectedLines[0].value); } catch (e) { } } }
      btnSearch.addEventListener('click', applySearch);
      txtLine.addEventListener('focus', function (ev) {
        updateAutocompleteList('');
      });
      txtLine.addEventListener('input', function (ev) {
        updateAutocompleteList(ev.target.value);
      });
      txtLine.addEventListener('blur', function () {
        setTimeout(function () {
          document.getElementById('autocompleteList').innerHTML = '';
        }, 200);
      });
      txtLine.addEventListener('keydown', function (ev) { if (ev.key === 'Enter') { applySearch(); } });
      renderSelectedLines();
      // populateLinesFromBuses removido: agora é feito em refreshBuses
    } catch (e) { }

    // Kick off initial buses refresh; preload lines for instant route drawing
    ensureLinesDataset().catch(function () { });
    ensureClusters();
    refreshBuses();
    // initial stops for current view
    try { loadStopsForBounds(map.getBounds()); } catch (e) { }
    map.on('moveend', function () { rnLog('MAP', 'moveend'); refreshBuses(); try { loadStopsForBounds(map.getBounds()); } catch (e) { } });
    setInterval(function () { refreshBuses(); }, 10000);
  </script>
</body>

</html>